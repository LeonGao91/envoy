diff --git a/api/envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.proto b/api/envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.proto
index b636aba859..b739a74e1d 100644
--- a/api/envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.proto
+++ b/api/envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.proto
@@ -31,7 +31,7 @@ message RedisProxy {
       "envoy.config.filter.network.redis_proxy.v2.RedisProxy";
 
   // Redis connection pool settings.
-  // [#next-free-field: 10]
+  // [#next-free-field: 12]
   message ConnPoolSettings {
     option (udpa.annotations.versioning).previous_message_type =
         "envoy.config.filter.network.redis_proxy.v2.RedisProxy.ConnPoolSettings";
@@ -127,6 +127,10 @@ message RedisProxy {
 
     // Read policy. The default is to read from the primary.
     ReadPolicy read_policy = 7 [(validate.rules).enum = {defined_only: true}];
+
+    bool redis_cx_rate_limit_enabled = 10;
+
+    uint32 redis_cx_rate_limit_per_sec = 11;
   }
 
   message PrefixRoutes {
diff --git a/source/extensions/clusters/redis/redis_cluster.h b/source/extensions/clusters/redis/redis_cluster.h
index 42b9ce94ce..8c72ba0de4 100644
--- a/source/extensions/clusters/redis/redis_cluster.h
+++ b/source/extensions/clusters/redis/redis_cluster.h
@@ -223,6 +223,8 @@ private:
     std::chrono::milliseconds bufferFlushTimeoutInMs() const override { return buffer_timeout_; }
     uint32_t maxUpstreamUnknownConnections() const override { return 0; }
     bool enableCommandStats() const override { return true; }
+    bool redisCxRateLimitEnabled() const override { return false; }
+    uint32_t redisCxRateLimitPerSec() const override { return 0; }
     // For any readPolicy other than Primary, the RedisClientFactory will send a READONLY command
     // when establishing a new connection. Since we're only using this for making the "cluster
     // slots" commands, the READONLY command is not relevant in this context. We're setting it to
diff --git a/source/extensions/filters/network/common/redis/client.h b/source/extensions/filters/network/common/redis/client.h
index f9835be412..9d7a32bea8 100644
--- a/source/extensions/filters/network/common/redis/client.h
+++ b/source/extensions/filters/network/common/redis/client.h
@@ -181,6 +181,9 @@ public:
    * @return the read policy the proxy should use.
    */
   virtual ReadPolicy readPolicy() const PURE;
+
+  virtual bool redisCxRateLimitEnabled() const PURE;
+  virtual uint32_t redisCxRateLimitPerSec() const PURE;
 };
 
 using ConfigSharedPtr = std::shared_ptr<Config>;
diff --git a/source/extensions/filters/network/common/redis/client_impl.cc b/source/extensions/filters/network/common/redis/client_impl.cc
index c34b7cfda5..a8a5fee6d2 100644
--- a/source/extensions/filters/network/common/redis/client_impl.cc
+++ b/source/extensions/filters/network/common/redis/client_impl.cc
@@ -28,7 +28,9 @@ ConfigImpl::ConfigImpl(
                // as the buffer is flushed on each request immediately.
       max_upstream_unknown_connections_(
           PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, max_upstream_unknown_connections, 100)),
-      enable_command_stats_(config.enable_command_stats()) {
+      enable_command_stats_(config.enable_command_stats()),
+      redis_cx_rate_limit_enabled_(config.redis_cx_rate_limit_enabled()),
+      redis_cx_rate_limit_per_sec_(config.redis_cx_rate_limit_per_sec()) {
   switch (config.read_policy()) {
     PANIC_ON_PROTO_ENUM_SENTINEL_VALUES;
   case envoy::extensions::filters::network::redis_proxy::v3::RedisProxy::ConnPoolSettings::MASTER:
diff --git a/source/extensions/filters/network/common/redis/client_impl.h b/source/extensions/filters/network/common/redis/client_impl.h
index 75b67f1509..908b57f4da 100644
--- a/source/extensions/filters/network/common/redis/client_impl.h
+++ b/source/extensions/filters/network/common/redis/client_impl.h
@@ -54,6 +54,8 @@ public:
   }
   bool enableCommandStats() const override { return enable_command_stats_; }
   ReadPolicy readPolicy() const override { return read_policy_; }
+  bool redisCxRateLimitEnabled() const override { return redis_cx_rate_limit_enabled_; }
+  uint32_t redisCxRateLimitPerSec() const override { return redis_cx_rate_limit_per_sec_; }
 
 private:
   const std::chrono::milliseconds op_timeout_;
@@ -64,6 +66,8 @@ private:
   const uint32_t max_upstream_unknown_connections_;
   const bool enable_command_stats_;
   ReadPolicy read_policy_;
+  const bool redis_cx_rate_limit_enabled_;
+  const uint32_t redis_cx_rate_limit_per_sec_;
 };
 
 class ClientImpl : public Client, public DecoderCallbacks, public Network::ConnectionCallbacks {
diff --git a/source/extensions/filters/network/redis_proxy/conn_pool_impl.cc b/source/extensions/filters/network/redis_proxy/conn_pool_impl.cc
index 3ff0ab6c7f..e4a8e3e565 100644
--- a/source/extensions/filters/network/redis_proxy/conn_pool_impl.cc
+++ b/source/extensions/filters/network/redis_proxy/conn_pool_impl.cc
@@ -179,6 +179,7 @@ void InstanceImpl::ThreadLocalPool::onClusterRemoval(const std::string& cluster_
 
   cluster_ = nullptr;
   host_address_map_.clear();
+  cx_rate_limiter_map_.clear();
 }
 
 void InstanceImpl::ThreadLocalPool::onHostsAdded(
@@ -201,6 +202,10 @@ void InstanceImpl::ThreadLocalPool::onHostsAdded(
 void InstanceImpl::ThreadLocalPool::onHostsRemoved(
     const std::vector<Upstream::HostSharedPtr>& hosts_removed) {
   for (const auto& host : hosts_removed) {
+    auto token_bucket = cx_rate_limiter_map_.find(host);
+    if (token_bucket != cx_rate_limiter_map_.end()) {
+      cx_rate_limiter_map_.erase(token_bucket);
+    }
     auto it = client_map_.find(host);
     if (it != client_map_.end()) {
       if (it->second->redis_client_->active()) {
@@ -236,14 +241,24 @@ void InstanceImpl::ThreadLocalPool::drainClients() {
 
 InstanceImpl::ThreadLocalActiveClientPtr&
 InstanceImpl::ThreadLocalPool::threadLocalActiveClient(Upstream::HostConstSharedPtr host) {
+  TokenBucketPtr& rate_limiter = cx_rate_limiter_map_[host];
+  if (config_->redisCxRateLimitEnabled() && !rate_limiter) {
+    rate_limiter = std::make_unique<TokenBucketImpl>(config_->redisCxRateLimitPerSec(),
+                                                     dispatcher_.timeSource(),
+                                                     config_->redisCxRateLimitPerSec());
+  }
   ThreadLocalActiveClientPtr& client = client_map_[host];
   if (!client) {
-    client = std::make_unique<ThreadLocalActiveClient>(*this);
-    client->host_ = host;
-    client->redis_client_ =
-        client_factory_.create(host, dispatcher_, *config_, redis_command_stats_, *(stats_scope_),
-                               auth_username_, auth_password_, false);
-    client->redis_client_->addConnectionCallbacks(*client);
+    if (!config_->redisCxRateLimitEnabled() || rate_limiter->consume(1, false) > 0) {
+      client = std::make_unique<ThreadLocalActiveClient>(*this);
+      client->host_ = host;
+      client->redis_client_ =
+          client_factory_.create(host, dispatcher_, *config_, redis_command_stats_, *(stats_scope_),
+                                 auth_username_, auth_password_, false);
+      client->redis_client_->addConnectionCallbacks(*client);
+    } else {
+      redis_cluster_stats_.redis_cx_rate_limited_.inc();
+    }
   }
   return client;
 }
@@ -283,9 +298,14 @@ InstanceImpl::ThreadLocalPool::makeRequest(const std::string& key, RespVariant&&
   PendingRequest& pending_request = pending_requests_.back();
 
   if (!transaction.active_) {
-    pending_request.request_handler_ =
-        this->threadLocalActiveClient(host)->redis_client_->makeRequest(
-            getRequest(pending_request.incoming_request_), pending_request);
+    ThreadLocalActiveClientPtr& client = this->threadLocalActiveClient(host);
+    if (!client) {
+      ENVOY_LOG(debug, "redis connection is rate limited, erasing empty client");
+      client_map_.erase(host);
+      return nullptr;
+    }
+    pending_request.request_handler_ = client->redis_client_->makeRequest(
+        getRequest(pending_request.incoming_request_), pending_request);
   } else {
     pending_request.request_handler_ = transaction.client_->makeRequest(
         getRequest(pending_request.incoming_request_), pending_request);
@@ -365,6 +385,11 @@ Common::Redis::Client::PoolRequest* InstanceImpl::ThreadLocalPool::makeRequestTo
   }
 
   ThreadLocalActiveClientPtr& client = threadLocalActiveClient(it->second);
+  if (!client) {
+    ENVOY_LOG(debug, "redis connection is rate limited, erasing empty client");
+    client_map_.erase(it->second);
+    return nullptr;
+  }
 
   return client->redis_client_->makeRequest(request, callbacks);
 }
diff --git a/source/extensions/filters/network/redis_proxy/conn_pool_impl.h b/source/extensions/filters/network/redis_proxy/conn_pool_impl.h
index 0e80638935..5efab4777e 100644
--- a/source/extensions/filters/network/redis_proxy/conn_pool_impl.h
+++ b/source/extensions/filters/network/redis_proxy/conn_pool_impl.h
@@ -13,6 +13,7 @@
 #include "envoy/upstream/cluster_manager.h"
 
 #include "source/common/buffer/buffer_impl.h"
+#include "source/common/common/token_bucket_impl.h"
 #include "source/common/network/address_impl.h"
 #include "source/common/network/filter_impl.h"
 #include "source/common/protobuf/utility.h"
@@ -41,7 +42,8 @@ namespace ConnPool {
 
 #define REDIS_CLUSTER_STATS(COUNTER)                                                               \
   COUNTER(upstream_cx_drained)                                                                     \
-  COUNTER(max_upstream_unknown_connections_reached)
+  COUNTER(max_upstream_unknown_connections_reached)                                                \
+  COUNTER(redis_cx_rate_limited)
 
 struct RedisClusterStats {
   REDIS_CLUSTER_STATS(GENERATE_COUNTER_STRUCT)
@@ -161,6 +163,7 @@ private:
     void onHostsAdded(const std::vector<Upstream::HostSharedPtr>& hosts_added);
     void onHostsRemoved(const std::vector<Upstream::HostSharedPtr>& hosts_removed);
     void drainClients();
+    bool consumeCxToken(Upstream::HostConstSharedPtr host);
 
     // Upstream::ClusterUpdateCallbacks
     void onClusterAddOrUpdate(Upstream::ThreadLocalCluster& cluster) override {
@@ -177,6 +180,8 @@ private:
     Upstream::ClusterUpdateCallbacksHandlePtr cluster_update_handle_;
     Upstream::ThreadLocalCluster* cluster_{};
     absl::node_hash_map<Upstream::HostConstSharedPtr, ThreadLocalActiveClientPtr> client_map_;
+    // todo: add config to enable this
+    absl::node_hash_map<Upstream::HostConstSharedPtr, TokenBucketPtr> cx_rate_limiter_map_;
     Envoy::Common::CallbackHandlePtr host_set_member_update_cb_handle_;
     absl::node_hash_map<std::string, Upstream::HostConstSharedPtr> host_address_map_;
     std::string auth_username_;
diff --git a/source/extensions/health_checkers/redis/redis.h b/source/extensions/health_checkers/redis/redis.h
index f1ce5ded62..95b89d290c 100644
--- a/source/extensions/health_checkers/redis/redis.h
+++ b/source/extensions/health_checkers/redis/redis.h
@@ -100,6 +100,8 @@ private:
 
     uint32_t maxUpstreamUnknownConnections() const override { return 0; }
     bool enableCommandStats() const override { return false; }
+    bool redisCxRateLimitEnabled() const override { return false; }
+    uint32_t redisCxRateLimitPerSec() const override { return 0; }
 
     // Extensions::NetworkFilters::Common::Redis::Client::ClientCallbacks
     void onResponse(NetworkFilters::Common::Redis::RespValuePtr&& value) override;
diff --git a/test/extensions/filters/network/common/redis/client_impl_test.cc b/test/extensions/filters/network/common/redis/client_impl_test.cc
index b95d9bfe14..7c50c1a1a9 100644
--- a/test/extensions/filters/network/common/redis/client_impl_test.cc
+++ b/test/extensions/filters/network/common/redis/client_impl_test.cc
@@ -190,6 +190,8 @@ class ConfigBufferSizeGTSingleRequest : public Config {
   uint32_t maxUpstreamUnknownConnections() const override { return 0; }
   bool enableCommandStats() const override { return false; }
   ReadPolicy readPolicy() const override { return ReadPolicy::Primary; }
+  bool redisCxRateLimitEnabled() const override { return false; }
+  uint32_t redisCxRateLimitPerSec() const override { return 0; }
 };
 
 TEST_F(RedisClientImplTest, BatchWithTimerFiring) {
@@ -349,6 +351,8 @@ class ConfigEnableCommandStats : public Config {
   ReadPolicy readPolicy() const override { return ReadPolicy::Primary; }
   uint32_t maxUpstreamUnknownConnections() const override { return 0; }
   bool enableCommandStats() const override { return true; }
+  bool redisCxRateLimitEnabled() const override { return false; }
+  uint32_t redisCxRateLimitPerSec() const override { return 0; }
 };
 
 void initializeRedisSimpleCommand(Common::Redis::RespValue* request, std::string command_name,
@@ -735,6 +739,8 @@ class ConfigOutlierDisabled : public Config {
   ReadPolicy readPolicy() const override { return ReadPolicy::Primary; }
   uint32_t maxUpstreamUnknownConnections() const override { return 0; }
   bool enableCommandStats() const override { return false; }
+  bool redisCxRateLimitEnabled() const override { return false; }
+  uint32_t redisCxRateLimitPerSec() const override { return 0; }
 };
 
 TEST_F(RedisClientImplTest, OutlierDisabled) {
diff --git a/test/extensions/filters/network/common/redis/test_utils.h b/test/extensions/filters/network/common/redis/test_utils.h
index 6d18e9dfb9..f317ecf4d4 100644
--- a/test/extensions/filters/network/common/redis/test_utils.h
+++ b/test/extensions/filters/network/common/redis/test_utils.h
@@ -21,13 +21,16 @@ createConnPoolSettings(
     uint32_t max_unknown_conns = 100,
     envoy::extensions::filters::network::redis_proxy::v3::RedisProxy::ConnPoolSettings::ReadPolicy
         read_policy = envoy::extensions::filters::network::redis_proxy::v3::RedisProxy::
-            ConnPoolSettings::MASTER) {
+            ConnPoolSettings::MASTER,
+    uint32_t redis_cx_rate_limit_per_sec = 100) {
   envoy::extensions::filters::network::redis_proxy::v3::RedisProxy::ConnPoolSettings setting{};
   setting.mutable_op_timeout()->CopyFrom(Protobuf::util::TimeUtil::MillisecondsToDuration(millis));
   setting.set_enable_hashtagging(hashtagging);
   setting.set_enable_redirection(redirection_support);
   setting.mutable_max_upstream_unknown_connections()->set_value(max_unknown_conns);
   setting.set_read_policy(read_policy);
+  setting.set_redis_cx_rate_limit_enabled(true);
+  setting.set_redis_cx_rate_limit_per_sec(redis_cx_rate_limit_per_sec);
   return setting;
 }
 
diff --git a/test/extensions/filters/network/redis_proxy/conn_pool_impl_test.cc b/test/extensions/filters/network/redis_proxy/conn_pool_impl_test.cc
index 27e9bcd001..3fe61a26bc 100644
--- a/test/extensions/filters/network/redis_proxy/conn_pool_impl_test.cc
+++ b/test/extensions/filters/network/redis_proxy/conn_pool_impl_test.cc
@@ -50,7 +50,8 @@ namespace ConnPool {
 class RedisConnPoolImplTest : public testing::Test, public Common::Redis::Client::ClientFactory {
 public:
   void setup(bool cluster_exists = true, bool hashtagging = true, uint32_t max_unknown_conns = 100,
-             const Extensions::Common::DynamicForwardProxy::DnsCacheSharedPtr dns_cache = nullptr) {
+             const Extensions::Common::DynamicForwardProxy::DnsCacheSharedPtr dns_cache = nullptr,
+             uint32_t redis_cx_rate_limit_per_sec = 100) {
     EXPECT_CALL(cm_, addThreadLocalClusterUpdateCallbacks_(_))
         .WillOnce(DoAll(SaveArgAddress(&update_callbacks_),
                         ReturnNew<Upstream::MockClusterUpdateCallbacksHandle>()));
@@ -85,7 +86,7 @@ public:
     std::shared_ptr<InstanceImpl> conn_pool_impl = std::make_shared<InstanceImpl>(
         cluster_name_, cm_, *this, tls_,
         Common::Redis::Client::createConnPoolSettings(20, hashtagging, true, max_unknown_conns,
-                                                      read_policy_),
+                                                      read_policy_, redis_cx_rate_limit_per_sec),
         api_, store_.rootScope(), redis_command_stats, cluster_refresh_manager_, dns_cache);
     conn_pool_impl->init();
     // Set the authentication password for this connection pool.
@@ -408,6 +409,53 @@ TEST_F(RedisConnPoolImplTest, ClientRequestFailed) {
   tls_.shutdownThread();
 };
 
+TEST_F(RedisConnPoolImplTest, RedisConnectionRateLimited) {
+  InSequence s;
+
+  setup(true, true, 100, nullptr, 1);
+
+  Common::Redis::RespValue value;
+  Common::Redis::Client::MockPoolRequest active_request;
+  MockPoolCallbacks callbacks;
+  Common::Redis::Client::MockClient* client = new NiceMock<Common::Redis::Client::MockClient>();
+  EXPECT_CALL(cm_.thread_local_cluster_.lb_, chooseHost(_))
+      .WillOnce(Invoke([&](Upstream::LoadBalancerContext* context) -> Upstream::HostConstSharedPtr {
+        EXPECT_EQ(context->computeHashKey().value(), MurmurHash::murmurHash2("hash_key"));
+        EXPECT_EQ(context->metadataMatchCriteria(), nullptr);
+        EXPECT_EQ(context->downstreamConnection(), nullptr);
+        return cm_.thread_local_cluster_.lb_.host_;
+      }));
+  EXPECT_CALL(*this, create_(_)).WillOnce(Return(client));
+  EXPECT_CALL(*cm_.thread_local_cluster_.lb_.host_, address())
+      .WillRepeatedly(Return(test_address_));
+  EXPECT_CALL(*client, makeRequest_(Eq(value), _)).WillOnce(Return(&active_request));
+  Common::Redis::Client::PoolRequest* request =
+      conn_pool_->makeRequest("hash_key", ConnPool::RespVariant(value), callbacks, transaction_);
+  EXPECT_NE(nullptr, request);
+
+  // close local and reconnect, should be rate limited and get null
+  EXPECT_CALL(tls_.dispatcher_, deferredDelete_(_));
+  client->raiseEvent(Network::ConnectionEvent::LocalClose);
+
+  EXPECT_CALL(cm_.thread_local_cluster_.lb_, chooseHost(_))
+      .WillOnce(Invoke([&](Upstream::LoadBalancerContext* context) -> Upstream::HostConstSharedPtr {
+        EXPECT_EQ(context->computeHashKey().value(), MurmurHash::murmurHash2("hash_key"));
+        EXPECT_EQ(context->metadataMatchCriteria(), nullptr);
+        EXPECT_EQ(context->downstreamConnection(), nullptr);
+        return cm_.thread_local_cluster_.lb_.host_;
+      }));
+  EXPECT_CALL(*this, create_(_)).Times(0);
+  EXPECT_CALL(*cm_.thread_local_cluster_.lb_.host_, address())
+      .WillRepeatedly(Return(test_address_));
+  Common::Redis::Client::PoolRequest* request2 =
+      conn_pool_->makeRequest("hash_key", ConnPool::RespVariant(value), callbacks, transaction_);
+  EXPECT_EQ(nullptr, request2);
+
+  EXPECT_CALL(active_request, cancel());
+  EXPECT_CALL(callbacks, onFailure_());
+  tls_.shutdownThread();
+};
+
 TEST_F(RedisConnPoolImplTest, BasicWithReadPolicy) {
   testReadPolicy(envoy::extensions::filters::network::redis_proxy::v3::RedisProxy::
                      ConnPoolSettings::PREFER_MASTER,
